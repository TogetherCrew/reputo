import { readdirSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface AlgorithmVersion {
  key: string;
  version: string;
  filePath: string;
}

function parseSemVer(version: string): {
  major: number;
  minor: number;
  patch: number;
  prerelease: string;
  build: string;
} {
  const regex = /^(\d+)\.(\d+)\.(\d+)(?:-([0-9A-Za-z-.]+))?(?:\+([0-9A-Za-z-.]+))?$/;
  const match = version.match(regex);

  if (!match) {
    throw new Error(`Invalid semantic version: ${version}`);
  }

  return {
    major: Number.parseInt(match[1] || '0', 10),
    minor: Number.parseInt(match[2] || '0', 10),
    patch: Number.parseInt(match[3] || '0', 10),
    prerelease: match[4] || '',
    build: match[5] || '',
  };
}

function compareSemVer(a: string, b: string): number {
  const aParsed = parseSemVer(a);
  const bParsed = parseSemVer(b);

  if (aParsed.major !== bParsed.major) return aParsed.major - bParsed.major;
  if (aParsed.minor !== bParsed.minor) return aParsed.minor - bParsed.minor;
  if (aParsed.patch !== bParsed.patch) return aParsed.patch - bParsed.patch;

  if (aParsed.prerelease && !bParsed.prerelease) return -1;
  if (!aParsed.prerelease && bParsed.prerelease) return 1;

  if (aParsed.prerelease !== bParsed.prerelease) {
    return aParsed.prerelease < bParsed.prerelease ? -1 : 1;
  }

  return 0;
}

function scanRegistry(registryPath: string): Map<string, AlgorithmVersion[]> {
  const registry = new Map<string, AlgorithmVersion[]>();

  const entries = readdirSync(registryPath, { withFileTypes: true });

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;

    const key = entry.name;
    const keyPath = join(registryPath, key);

    const versionFiles = readdirSync(keyPath, { withFileTypes: true });

    for (const versionFile of versionFiles) {
      if (!versionFile.isFile() || !versionFile.name.endsWith('.json')) continue;

      const version = versionFile.name.replace('.json', '');
      const filePath = join(keyPath, versionFile.name);

      if (!registry.has(key)) {
        registry.set(key, []);
      }

      registry.get(key)?.push({ key, version, filePath });
    }
  }

  return registry;
}

function generateRegistryIndex(registry: Map<string, AlgorithmVersion[]>): string {
  const lines: string[] = [];

  lines.push('// This file is auto-generated by gen-registry.ts');
  lines.push('// Do not edit manually');
  lines.push('');

  const sortedKeys = Array.from(registry.keys()).sort();

  lines.push('export const REGISTRY_INDEX = {');
  for (const key of sortedKeys) {
    const versions = registry.get(key) || [];
    const sortedVersions = versions.map((v) => v.version).sort(compareSemVer);

    const versionStrings = sortedVersions.map((v) => `"${v}"`).join(', ');
    lines.push(`  ${key}: [${versionStrings}],`);
  }
  lines.push('} as const;');
  lines.push('');

  const imports: string[] = [];
  const definitions: string[] = [];

  for (const key of sortedKeys) {
    const versions = registry.get(key) || [];

    for (const { version } of versions) {
      const sanitizedKey = key;
      const sanitizedVersion = version.replace(/[.-]/g, '_');
      const importName = `_${sanitizedKey}_${sanitizedVersion}`;
      const relativePath = `./${key}/${version}.json`;

      imports.push(`import ${importName} from "${relativePath}" with { type: "json" };`);
      definitions.push(`  "${key}@${version}": ${importName},`);
    }
  }

  lines.push(...imports);
  lines.push('');
  lines.push('export const _DEFINITIONS = {');
  lines.push(...definitions);
  lines.push('} as const;');
  lines.push('');

  return lines.join('\n');
}

function main(): void {
  const registryPath = join(__dirname, '../registry');
  const outputPath = join(registryPath, 'index.gen.ts');

  console.log('Generating registry index...');
  console.log(`Registry path: ${registryPath}`);

  const registry = scanRegistry(registryPath);

  console.log(`Found ${registry.size} algorithm(s):`);
  for (const [key, versions] of registry) {
    console.log(`  - ${key}: ${versions.length} version(s)`);
  }

  const indexContent = generateRegistryIndex(registry);
  writeFileSync(outputPath, indexContent, 'utf-8');

  console.log(`âœ“ Registry index generated: ${outputPath}`);
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { scanRegistry, generateRegistryIndex, compareSemVer };
