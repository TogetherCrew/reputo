import { readdirSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { compareSemVer } from '../shared/utils/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

interface AlgorithmVersion {
  key: string;
  version: string;
  filePath: string;
}

function scanRegistry(registryPath: string): Map<string, AlgorithmVersion[]> {
  const registry = new Map<string, AlgorithmVersion[]>();

  const entries = readdirSync(registryPath, { withFileTypes: true });

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;

    const key = entry.name;
    const keyPath = join(registryPath, key);

    const versionFiles = readdirSync(keyPath, { withFileTypes: true });

    for (const versionFile of versionFiles) {
      if (!versionFile.isFile() || !versionFile.name.endsWith('.json')) continue;

      const version = versionFile.name.replace('.json', '');
      const filePath = join(keyPath, versionFile.name);

      if (!registry.has(key)) {
        registry.set(key, []);
      }

      registry.get(key)?.push({ key, version, filePath });
    }
  }

  return registry;
}

function generateRegistryIndex(registry: Map<string, AlgorithmVersion[]>): string {
  const lines: string[] = [];

  lines.push('// This file is auto-generated by gen-registry.ts');
  lines.push('// Do not edit manually');
  lines.push('');
  lines.push('import type { AlgorithmDefinition } from "../shared/types/index.js"');
  lines.push('');

  const sortedKeys = Array.from(registry.keys()).sort();

  // Generate REGISTRY_INDEX type
  lines.push('export const REGISTRY_INDEX = {');
  for (const key of sortedKeys) {
    const versions = registry.get(key) || [];
    const sortedVersions = versions.map((v) => v.version).sort(compareSemVer);

    const versionStrings = sortedVersions.map((v) => `'${v}'`).join(', ');
    lines.push(`    ${key}: [${versionStrings}],`);
  }
  lines.push('} as const');
  lines.push('');

  const imports: string[] = [];
  const definitions: string[] = [];

  for (const key of sortedKeys) {
    const versions = registry.get(key) || [];

    for (const { version } of versions) {
      const sanitizedKey = key;
      const sanitizedVersion = version.replace(/[.-]/g, '_');
      const importName = `_${sanitizedKey}_${sanitizedVersion}`;
      const relativePath = `./${key}/${version}.json`;

      imports.push(`import ${importName} from '${relativePath}'`);
      definitions.push(`    '${key}@${version}': ${importName} as AlgorithmDefinition,`);
    }
  }

  lines.push(...imports);
  lines.push('');
  lines.push('export const _DEFINITIONS: Record<string, AlgorithmDefinition> = {');
  lines.push(...definitions);
  lines.push('} as const');
  lines.push('');

  return lines.join('\n');
}

function main(): void {
  const registryPath = join(__dirname, '../registry');
  const outputPath = join(registryPath, 'index.gen.ts');

  console.log('Generating registry index...');
  console.log(`Registry path: ${registryPath}`);

  const registry = scanRegistry(registryPath);

  console.log(`Found ${registry.size} algorithm(s):`);
  for (const [key, versions] of registry) {
    console.log(`  - ${key}: ${versions.length} version(s)`);
  }

  const indexContent = generateRegistryIndex(registry);
  writeFileSync(outputPath, indexContent, 'utf-8');

  console.log(`âœ“ Registry index generated: ${outputPath}`);
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

export { scanRegistry, generateRegistryIndex };
