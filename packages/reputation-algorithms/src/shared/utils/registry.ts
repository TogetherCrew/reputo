import { readdirSync } from 'node:fs';
import { join } from 'node:path';
import type { AlgorithmVersion, RegistryIndex } from '../types/registry';
import { compareSemVer } from './validation';

export function scanRegistryDirectory(registryPath: string): RegistryIndex {
  const algorithmMap = new Map<string, AlgorithmVersion[]>();
  let totalVersions = 0;

  try {
    const entries = readdirSync(registryPath, { withFileTypes: true });

    for (const entry of entries) {
      if (!entry.isDirectory()) continue;

      const key = entry.name;
      const keyPath = join(registryPath, key);

      const versions = scanAlgorithmVersions(keyPath, key);
      if (versions.length > 0) {
        algorithmMap.set(key, versions);
        totalVersions += versions.length;
      }
    }
  } catch (error) {
    throw new Error(`Failed to scan registry directory: ${error instanceof Error ? error.message : String(error)}`);
  }

  return {
    algorithms: algorithmMap,
    totalAlgorithms: algorithmMap.size,
    totalVersions,
  };
}

function scanAlgorithmVersions(keyPath: string, key: string): AlgorithmVersion[] {
  const versions: AlgorithmVersion[] = [];

  try {
    const versionFiles = readdirSync(keyPath, { withFileTypes: true });

    for (const versionFile of versionFiles) {
      if (!versionFile.isFile() || !versionFile.name.endsWith('.json')) {
        continue;
      }

      const version = versionFile.name.replace('.json', '');
      const filePath = join(keyPath, versionFile.name);

      versions.push({ key, version, filePath });
    }
  } catch (error) {
    console.warn(
      `Warning: Could not scan versions for algorithm '${key}': ${error instanceof Error ? error.message : String(error)}`,
    );
  }

  return versions;
}

export function generateRegistryIndexContent(registryIndex: RegistryIndex, includeMetadata = true): string {
  const lines: string[] = [];

  lines.push('// This file is auto-generated - DO NOT EDIT MANUALLY');
  lines.push('// Generated by: registry-generator.ts');
  if (includeMetadata) {
    lines.push(`// Last generated: ${new Date().toISOString()}`);
  }
  lines.push('');

  const sortedKeys = Array.from(registryIndex.algorithms.keys()).sort();

  generateRegistryIndexConstant(lines, registryIndex, sortedKeys);

  const { imports, definitions } = generateImportsAndDefinitions(registryIndex, sortedKeys);

  lines.push(...imports);
  lines.push('');
  lines.push('export const _DEFINITIONS: Record<string, unknown> = {');
  lines.push(...definitions);
  lines.push('} as const;');
  lines.push('');

  return lines.join('\n');
}

function generateRegistryIndexConstant(
  lines: string[],
  registryIndex: RegistryIndex,
  sortedKeys: readonly string[],
): void {
  lines.push('export const REGISTRY_INDEX = {');

  for (const key of sortedKeys) {
    const versions = registryIndex.algorithms.get(key) ?? [];
    const sortedVersions = versions.map((v) => v.version).sort(compareSemVer);

    const versionStrings = sortedVersions.map((v) => `'${v}'`).join(', ');

    lines.push(`  ${key}: [${versionStrings}],`);
  }

  lines.push('} as const;');
  lines.push('');
}

function generateImportsAndDefinitions(
  registryIndex: RegistryIndex,
  sortedKeys: readonly string[],
): { imports: string[]; definitions: string[] } {
  const imports: string[] = [];
  const definitions: string[] = [];

  for (const key of sortedKeys) {
    const versions = registryIndex.algorithms.get(key) ?? [];

    for (const { version } of versions) {
      const importName = generateImportName(key, version);
      const relativePath = `./${key}/${version}.json`;
      const definitionKey = `${key}@${version}`;

      imports.push(`import ${importName} from '${relativePath}';`);
      definitions.push(`  '${definitionKey}': ${importName} as unknown,`);
    }
  }

  return { imports, definitions };
}

function generateImportName(key: string, version: string): string {
  const sanitizedKey = key.replace(/[^a-zA-Z0-9]/g, '_');
  const sanitizedVersion = version.replace(/[.-]/g, '_');
  return `_${sanitizedKey}_${sanitizedVersion}`;
}

export function generateRegistryStats(registryIndex: RegistryIndex): string {
  const lines: string[] = [];
  lines.push(
    `Found ${registryIndex.totalAlgorithms} algorithm(s) with ${registryIndex.totalVersions} total version(s):`,
  );

  for (const [key, versions] of registryIndex.algorithms) {
    const versionCount = versions.length;
    const versionList = versions
      .map((v) => v.version)
      .sort(compareSemVer)
      .join(', ');
    lines.push(`  - ${key}: ${versionCount} version(s) [${versionList}]`);
  }

  return lines.join('\n');
}
