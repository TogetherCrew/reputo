import type { RegistryIndex } from '../types/registry.js';
import { compareSemVer } from './semver.js';

/**
 * Generates TypeScript registry index content from discovered algorithms
 */
export function generateRegistryIndexContent(registryIndex: RegistryIndex): string {
  const lines: string[] = [];

  // Header
  lines.push('// This file is auto-generated - DO NOT EDIT MANUALLY');
  lines.push('// Generated by: registry-generator.ts');
  lines.push(`// Last generated: ${new Date().toISOString()}`);
  lines.push('');
  lines.push('import type { AlgorithmDefinition } from "../shared/types/index.js";');
  lines.push('');

  const sortedKeys = Array.from(registryIndex.algorithms.keys()).sort();

  // Generate REGISTRY_INDEX constant
  generateRegistryIndexConstant(lines, registryIndex, sortedKeys);

  // Generate imports and definitions
  const { imports, definitions } = generateImportsAndDefinitions(registryIndex, sortedKeys);

  lines.push(...imports);
  lines.push('');
  lines.push('export const _DEFINITIONS: Record<string, AlgorithmDefinition> = {');
  lines.push(...definitions);
  lines.push('} as const;');
  lines.push('');

  return lines.join('\n');
}

/**
 * Generates the REGISTRY_INDEX constant
 */
function generateRegistryIndexConstant(
  lines: string[],
  registryIndex: RegistryIndex,
  sortedKeys: readonly string[],
): void {
  lines.push('export const REGISTRY_INDEX = {');

  for (const key of sortedKeys) {
    const versions = registryIndex.algorithms.get(key) ?? [];
    const sortedVersions = versions.map((v) => v.version).sort(compareSemVer);

    const versionStrings = sortedVersions.map((v) => `'${v}'`).join(', ');

    lines.push(`  ${key}: [${versionStrings}],`);
  }

  lines.push('} as const;');
  lines.push('');
}

/**
 * Generates import statements and definition entries
 */
function generateImportsAndDefinitions(
  registryIndex: RegistryIndex,
  sortedKeys: readonly string[],
): { imports: string[]; definitions: string[] } {
  const imports: string[] = [];
  const definitions: string[] = [];

  for (const key of sortedKeys) {
    const versions = registryIndex.algorithms.get(key) ?? [];

    for (const { version } of versions) {
      const importName = generateImportName(key, version);
      const relativePath = `./${key}/${version}.json`;
      const definitionKey = `${key}@${version}`;

      imports.push(`import ${importName} from '${relativePath}';`);
      definitions.push(`  '${definitionKey}': ${importName} as AlgorithmDefinition,`);
    }
  }

  return { imports, definitions };
}

/**
 * Generates safe import name from algorithm key and version
 */
function generateImportName(key: string, version: string): string {
  const sanitizedKey = key.replace(/[^a-zA-Z0-9]/g, '_');
  const sanitizedVersion = version.replace(/[.-]/g, '_');
  return `_${sanitizedKey}_${sanitizedVersion}`;
}

/**
 * Generates registry statistics for logging
 */
export function generateRegistryStats(registryIndex: RegistryIndex): string {
  const lines: string[] = [];
  lines.push(
    `Found ${registryIndex.totalAlgorithms} algorithm(s) with ${registryIndex.totalVersions} total version(s):`,
  );

  for (const [key, versions] of registryIndex.algorithms) {
    const versionCount = versions.length;
    const versionList = versions
      .map((v) => v.version)
      .sort(compareSemVer)
      .join(', ');
    lines.push(`  - ${key}: ${versionCount} version(s) [${versionList}]`);
  }

  return lines.join('\n');
}
